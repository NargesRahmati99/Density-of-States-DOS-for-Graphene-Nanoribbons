# -*- coding: utf-8 -*-
"""main graphene nanoribbons DOS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B7pUc-jH16WzzzRou1eeSnJaYBEC3rx4
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

# Constants
t_cc = -2.7  # Carbon-carbon hopping parameter (eV)
t_cs = -1.5  # Carbon-silicon hopping parameter (eV)
t_ss = -1.0  # Silicon-silicon hopping parameter (eV)
epsilon_c = 0.0  # On-site energy for carbon (eV)
epsilon_s = 1.1  # On-site energy for silicon (eV)
a = 1.42  # Carbon-carbon bond length (Ã…)
eta = 0.05  # Broadening parameter (eV)

def create_lattice(N, lattice_type, replace_with_si=False):
    """
    Create the positions of atoms in a graphene nanoribbon.
    Args:
        N (int): Number of unit cells.
        lattice_type (str): 'zigzag' or 'armchair'.
        replace_with_si (bool): Whether to replace carbon atoms with silicon.
    Returns:
        positions (np.array): Array of atom positions.
        num_atoms (int): Total number of atoms.
    """
    if lattice_type == 'zigzag':
        num_atoms = 2 * N
        positions = np.zeros((num_atoms, 2))
        for i in range(N):
            positions[2*i] = [i * 3 * a / 2, 0]
            positions[2*i + 1] = [i * 3 * a / 2 + a, a * np.sqrt(3) / 2]
    elif lattice_type == 'armchair':
        num_atoms = 4 * N
        positions = np.zeros((num_atoms, 2))
        for i in range(N):
            positions[4*i] = [i * a, 0]
            positions[4*i + 1] = [i * a + a / 2, a * np.sqrt(3) / 2]
            positions[4*i + 2] = [i * a + a, 0]
            positions[4*i + 3] = [i * a + 3 * a / 2, a * np.sqrt(3) / 2]
    else:
        raise ValueError("Invalid lattice type. Choose 'zigzag' or 'armchair'.")

    return positions, num_atoms

def construct_hamiltonian(positions, num_atoms, replace_with_si=False):
    """
    Construct the tight-binding Hamiltonian for the lattice.
    Args:
        positions (np.array): Array of atom positions.
        num_atoms (int): Total number of atoms.
        replace_with_si (bool): Whether to replace carbon atoms with silicon.
    Returns:
        H (np.array): Tight-binding Hamiltonian.
    """
    H = np.zeros((num_atoms, num_atoms))

    # Set on-site energies
    for i in range(num_atoms):
        if replace_with_si and i % 2 == 1:  # Replace every other carbon with silicon
            H[i, i] = epsilon_s
        else:
            H[i, i] = epsilon_c

    # Set hopping terms
    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            dx = positions[i, 0] - positions[j, 0]
            dy = positions[i, 1] - positions[j, 1]
            distance = np.sqrt(dx**2 + dy**2)

            if np.abs(distance - a) < 1e-2:  # Nearest neighbors
                if replace_with_si and (i % 2 == 1 or j % 2 == 1):
                    H[i, j] = t_cs
                    H[j, i] = t_cs
                else:
                    H[i, j] = t_cc
                    H[j, i] = t_cc

    return H

def calculate_dos(H, energy_range, eta=0.05):
    """
    Calculate the Density of States (DOS) using the Green's function method.
    Args:
        H (np.array): Hamiltonian matrix.
        energy_range (np.array): Array of energy values.
        eta (float): Broadening parameter.
    Returns:
        dos (np.array): Density of States.
    """
    num_atoms = H.shape[0]
    dos = np.zeros_like(energy_range)

    for i, E in enumerate(energy_range):
        G = np.linalg.inv((E + 1j * eta) * np.eye(num_atoms) + H)
        dos[i] = -np.imag(np.trace(G)) / np.pi

    return dos

def plot_dos(energy_range, dos_c, dos_si, lattice_type):
    """
    Plot the Density of States (DOS) for carbon and silicon-doped systems.
    Args:
        energy_range (np.array): Array of energy values.
        dos_c (np.array): DOS for carbon system.
        dos_si (np.array): DOS for silicon-doped system.
        lattice_type (str): 'zigzag' or 'armchair'.
    """
    plt.figure(figsize=(8, 6))
    plt.plot(energy_range, dos_c, label=f'{lattice_type.capitalize()} (C)')
    plt.plot(energy_range, dos_si, label=f'{lattice_type.capitalize()} (C-Si)')
    plt.xlabel('Energy (eV)')
    plt.ylabel('DOS')
    plt.title(f'Density of States for {lattice_type.capitalize()} Nanoribbon')
    plt.legend()
    plt.grid(True)
    plt.show()

# Main script
N = 20  # Number of unit cells
energy_range = np.linspace(-5, 5, 500)  # Energy range for DOS calculation

# Zigzag nanoribbon
positions_zigzag, num_atoms_zigzag = create_lattice(N, 'zigzag')
H_zigzag_c = construct_hamiltonian(positions_zigzag, num_atoms_zigzag, replace_with_si=False)
H_zigzag_si = construct_hamiltonian(positions_zigzag, num_atoms_zigzag, replace_with_si=True)
dos_zigzag_c = calculate_dos(H_zigzag_c, energy_range, eta)
dos_zigzag_si = calculate_dos(H_zigzag_si, energy_range, eta)
plot_dos(energy_range, dos_zigzag_c, dos_zigzag_si, 'zigzag')

# Armchair nanoribbon
positions_armchair, num_atoms_armchair = create_lattice(N, 'armchair')
H_armchair_c = construct_hamiltonian(positions_armchair, num_atoms_armchair, replace_with_si=False)
H_armchair_si = construct_hamiltonian(positions_armchair, num_atoms_armchair, replace_with_si=True)
dos_armchair_c = calculate_dos(H_armchair_c, energy_range, eta)
dos_armchair_si = calculate_dos(H_armchair_si, energy_range, eta)
plot_dos(energy_range, dos_armchair_c, dos_armchair_si, 'armchair')